#!/usr/bin/env python3
# vim:fileencoding=utf-8

'''
WebQQ 代理，可对消息进行通知等

2010年8月25日
'''

from webqq.qqproxy import ThreadingQQProxyServer
from webqq.message import *
import threading
import sys, os
import socket

QQNameDict = {}

sockfile = None

def print(*args, sep=' ', end='\n', file=sys.stdout):
  __builtins__.print('\x1b[32m', end='')
  __builtins__.print(*args, sep=sep, end=end, file=file)
  __builtins__.print('\x1b[0m', end='')
  sys.stdout.flush()

def init():
  for i in open('/home/lilydjwg/TODO/QQNameDict'):
    l = i.split()
    QQNameDict[l[0]] = l[1]

  oldhd = logger.handlers[0]
  oldhd.setLevel(logging.INFO)

  # global sockfile
  # s = socket.socket(socket.AF_UNIX)
  # s.connect('/home/lilydjwg/tmpfs/webqq')
  # sockfile = s.makefile('w', 1)

  # hd = logging.FileHandler(os.path.expanduser('~/TODO/webqq.log'))
  # hd.setLevel(logging.DEBUG)
  # hd.setFormatter(oldhd.formatter)
  # logger.addHandler(hd)

def QQNo2name(QQNumber):
  try:
    return QQNameDict[QQNumber]
  except KeyError:
    return QQNumber

def showmsg(self, **msg):
  if msg['Message'] == '您好，我现在有事不在，一会再和您联系。':
    return
  toshow = msg['Message'].replace('\x14', '^T').replace('\x15', '^U').replace('\x1f', '^_')
  if len(toshow) > 100:
    toshow = '(大量信息)'
  os.system('''gnome-osd-client -f "<message id='{qq}' osd_fake_translucent_bg='off' osd_vposition='top' animations='on' hide_timeout='30000' osd_halignment='center'><span foreground='pink'>{who}：</span>{what}</message>"'''.format(
    qq=msg['RemoteQQ'], who=QQNo2name(msg['RemoteQQ']), what=toshow))
def msgrecv(self, **msg):
    print('%s 说 %s' % (QQNo2name(msg['RemoteQQ']), msg['Message']))
def msgsent(self, **msg):
  print('对 %s 说 %s' % (QQNo2name(msg['RemoteQQ']), msg['Message']))
def statuschange(self, **msg):
  print('%s 的状态为 %s, 使用 %s' % (QQNo2name(msg['RemoteQQ']),
    状态[msg['Status']], 客户端[msg['ClientType']]))

def registerHandlers(handler):
  handler.recvedHandler.addEventListener('MessageRecved', msgrecv)
  handler.recvedHandler.addEventListener('MessageRecved', showmsg)
  handler.recvedHandler.addEventListener('MessageSent', msgsent)
  handler.recvedHandler.addEventListener('BuddyStatus', statuschange)

class MyHandler(QQMessageHandler):
  def __call__(self, msg, dir):
    super().__call__(msg, dir)
    try:
      print(dir, msg.split(';')[2])
    except IndexError:
      pass

if __name__ == '__main__':
  init()
  handler = MyHandler()
  registerHandlers(handler)

  httpd = ThreadingQQProxyServer(('', 7777), handler)
  print('QQProxy Server started on 0.0.0.0, port 7777......')

  try:
    httpd.serve_forever()
  except KeyboardInterrupt:
    print("\nKeyboard interrupt received, exiting.")
    httpd.server_close()

